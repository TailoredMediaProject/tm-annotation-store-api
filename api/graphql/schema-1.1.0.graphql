#Scalars
scalar URL

scalar Void

# Interfaces
"All resources must have at least *id* and *type*"
interface ResourceI {
    id: URL!
    type: URL!
}

"A blank node just have just a *type*"
interface BlankI {
    type: URL!
}

interface IBody {
    id: String!
    confidence: Int
    type: String!
}

interface ITarget {
    source: String!
    type: String!
}

interface ISelector {
    type: String!
}

# Unions
"all supported targets"
union Target = TargetResource | FragmentResource

"all supported bodies"
union Body = MetadataBody | ResourceBody | PartBody

"all supported selectors"
union Selector = TextPositionSelector | TextQuoteSelector | MediaFragmentSelector | TemporalFragmentSelector | PercentSpatialSelector


# Types
"a annotation that links a target (thing to tag) with body (tag)"
type Annotation {
    id: URL!
    origin: Origin!
    replaces: String
    replacedBy: String
    created: String!
    "tag, e.g. the resource 'Mick Schumacher'"
    body: Body! #resource Barack Obama
    "thing to tag, e.g. a news article or a part of an image"
    target: Target! #Part of a text
}

type Origin {
    type: String!
    creator: String!
}

type MetadataBody implements IBody {
    id: String!
    confidence: Int
    type: String!
    relation: String
    value: String
}

type ResourceBody implements IBody {
    id: String!
    confidence: Int
    type: String!
    relation: String
    value: String
}

type PartBody implements IBody {
    id: String!
    confidence: Int
    type: String!
}

type TargetResource implements ITarget {
    source: String!
    type: String!
    selector: [Selector!]!
}

type FragmentResource implements ITarget {
    type: String!
    source: String!
}

type TextPositionSelector implements ISelector {
    type: String!
    start: Int
    end: Int
}

type TextQuoteSelector implements ISelector {
    type: String!
    exact: String!
    prefix: String
    suffix: String
}

type MediaFragmentSelector implements ISelector {
    type: String!
    temporal: TemporalFragmentSelector
    percent: PercentSpatialSelector
}

type TemporalFragmentSelector implements ISelector {
    type: String!
    start: Int
    end: Int
}

type PercentSpatialSelector implements ISelector {
    type: String!
    x: Int
    y: Int
    w: Int
    h: Int
}

# Query
type Query {
    "return all annotations that match the filter criteria"
    annotations(filter: Filter): [Annotation]!
    "return one annotation by id"
    annotation(id: URL!): Annotation
}

# Query Input
"a filter, currently only targetId (id of target or source of SpecificResource) is supported"
input Filter {
    targetId: String!
}

# Mutation
type Mutation {
    "add a annotation: select *one* type of body and *one* type of target (will be improved as soon as interfaces for inputs are supported"
    addAnnotation(
        bodyResource: BodyResourceInput,
        bodyText: BodyTextInput,
        targetResource: TargetResourceInput,
        targetTextSelector: TargetTextSelectorInput,
        targetFragmentSelector: TargetFragmentSelectorInput
    ): Annotation
    "delete one annotation by id"
    deleteAnnotation(
        id: URL!
    ): Void
    "delete all annotations that match the filter criteria"
    deleteAnnotations(
        filter: Filter!
    ): Void
}

# Mutation Input
"a basic body resource, e.g. an entity of an existing taxonomy. Label is optinal and only for demo purposes"
input BodyResourceInput {
    id: URL!
    type: URL!
    label: String
}

"a textual body (like a comment), mostly for demo purposes"
input BodyTextInput {
    value: String!
}

"a target resource, e.g. an image"
input TargetResourceInput {
    id: URL!, type: URL!
}

"a part on a text; at least one selector has to be set"
input TargetTextSelectorInput {
    source: URL!
    textPositionSelector: TextPositionSelectorInput
    textQuoteSelector: TextQuoteSelectorInput
}

"a part of a text; start and end are specified via character position; exact text included, prefix and suffix optional"
input TextPositionSelectorInput {
    start: Int!
    end: Int!
}

"a part of a text; exact text included, prefix and suffix optional"
input TextQuoteSelectorInput {
    exact: String!
    prefix: String
    suffix: String
}

"a part of an entity, selection is done using a choosable standard"
input TargetFragmentSelectorInput {
    source: URL!
    "the standard that is used to interpret the value"
    conformsTo: String!
    "a value using the specified standard"
    value: String!
}
