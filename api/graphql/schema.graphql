#Scalars
scalar URL
scalar Void
scalar Literal
scalar Date
scalar RDF
scalar Ebucore
scalar Relation

# Interfaces
"All resources must have at least *id* and *type*"
interface ResourceI {
    id: URL!
    type: URL!
}

"A blank node just have just a *type*"
interface BlankI {
    type: URL!
}

"All Annotations must have at least *id* and *origin*"
interface AnnotationI{
    id: URL!
    replaces: URL
    replacedBy: URL
    created: Date!
    origin: Origin!
}

interface MetadataI{
    type: URL!
    id: URL!
    relation: URL!
    value: [Literal!]
    confidence: Float
}

# Unions
"all supported targets"
union Target = TargetResource | TargetFragment

"all supported bodies"
union Body = BodyResource | BodyText | BodyMetadata | BodyPart

"all supported selectors"
union Selector = TextPositionSelector | TextQuoteSelector | FragmentSelector

"all literal types and an array of them for Metadata: value"
union Literal = String | Float | Boolean | Date | Literal | RDF | Ebucore

"Constant for all types of different relations"
union Relation = RDF | Ebucore

# Types
"a annotation that links a target (thing to tag) with body (tag)"
type Annotation implements AnnotationI{
    id: URL!
    origin: Origin!
    replacedBy: URL
    replaces: URL
    created: Date!
    "tag, e.g. the resource 'Mick Schumacher'"
    body: [Body!]! #resource Barack Obama
    "thing to tag, e.g. a news article or a part of an image"
    target: Target! #Part of a text
}

"origin provides metadata about annotation"
type Origin{
    type: String!
    creator: String!
    modality: String!
}

# Body
"a body represented by an entity, e.g. from an existing taxonomy"
type BodyResource implements ResourceI {
    id: URL!
    type: URL!
    resource: URL!
    confidence: Float
}

"a freetext body (more for demo purposes)"
type BodyText implements BlankI {
    type: URL!
    value: String!
    confidence: Float
}

"a BodyPart for scene annotation"
type BodyPart implements ResourceI{
    id: URL!
    type: URL!
    confidence: Float
}

"a metadata body"
type BodyMetadata implements MetadataI{
    type: URL!
    id: URL!
    relation: URL!
    value: [Literal!]
    confidence: Float
}

#    For `value: Literal` pair
#    Use the String type and JSON.stringifying the data before setting it on the field.
#    So everything gets stringified, and later you just JSON.parse the result and
#    get back the desired object/array/boolean/ etc.

#    getValue(): any {
#        return JSON.parse(this.value);
#    }


#   New "Sub-Bodies":
type BodySendung{
    type: URL!
    id: URL!
    relation: RDF
    value: Ebucore
    confidence: Float
}

type BodyBeitrag{
    type: URL!
    id: URL!
    relation: RDF
    value: Ebucore
    confidence: Float
}

type BodyShot{
    type: URL!
    id: URL!
    relation: RDF
    value: Ebucore
    confidence: Float
}

type BodyKeyframe{
    type: URL!
    id: URL!
    relation: RDF
    value: [Relation]
    confidence: Float
}


# Target
"a body represented by an entity, e.g. a news artile or an image"
type TargetResource implements BlankI {
    source: URL!
    type: URL!
}

"a part of an entity, e.g. a fragment of an image or a part of a text"
type TargetFragment implements BlankI {
    type: URL!
    "the base of the selector, e.g. the image resource"
    source: URL!
    "one or more specifications, e.g. a rectangular area that determines a part of the image"
    selector: [Selector!]!
}

# Selector
"a selector to identify part of textual resources via start and end character"
type TextPositionSelector implements BlankI {
    type: URL!
    start: Int
    end: Int
}

"a selector to identify part of textual resources by exact mention, prefix and suffix are optional"
type TextQuoteSelector implements BlankI {
    type: URL!
    exact: String !
    prefix: String
    suffix: String
}

#"a selector to identify a part of a media resource. the value must be interpreted via the specified standard"
#type FragmentSelector implements BlankI {
#    type: URL!
#    "the standard that is used to interpret the value"
#    conformsTo: URL!
#    "the value based on the standard"
#    value: String!
#}

"a selector for a timeline on the video"
type NptTimeSelector implements BlankI{
    type: URL!
    start: Float
    end: Float
}

"a selector for specific region of the view"
type PercentSpatialSelector implements BlankI{
    type: URL!
    x: Float!
    y: Float!
    w: Float!
    h: Float!
}

"a selector for a clip: timeline + view"
type FragmentSelector implements BlankI{
    type: URL!
    conformsTo: URL!
    value: Literal
    refinedBy: [PercentSpatialSelector]
    temporal: NptTimeSelector
    spatial: PercentSpatialSelector
}

# Query
type Query {
    "return all annotations that match the filter criteria"
    annotations(filter: Filter): [Annotation]!
    "return one annotation by id"
    annotation(id: URL!): Annotation
}

# Query Input
"a filter, currently only targetId (id of target or source of SpecificResource) is supported"
input Filter {
    targetId: String!
}

# Mutation
type Mutation {
    "add an annotation: select *one* type of body and *one* type of target (will be improved as soon as interfaces for inputs are supported"
    addAnnotation(
        bodyResource: BodyResourceInput,
        bodyText: BodyTextInput,
        bodyMetadata: BodyMetadataInput,
        targetResource: TargetResourceInput,
        targetTextSelector: TargetTextSelectorInput,
        targetFragmentSelector: TargetFragmentSelectorInput
    ): Annotation
    "delete one annotation by id"
    deleteAnnotation(
        id: URL!
    ): Void
    "delete all annotations that match the filter criteria"
    deleteAnnotations(
        filter: Filter!
    ): Void
}

# Mutation Input
"a basic body resource, e.g. an entity of an existing taxonomy. Label is optinal and only for demo purposes"
input BodyResourceInput {
    id: URL!
    type: URL!
    label: String
    relation: String
    value: String
}

input BodyMetadataInput{
    type: URL!
    id: URL!
    relation: String!
    value: String!

}

"a textual body (like a comment), mostly for demo purposes"
input BodyTextInput {
    value: String!
}

"a target resource, e.g. an image"
input TargetResourceInput {
    id: URL!, type: URL!
}

"a part on a text; at least one selector has to be set"
input TargetTextSelectorInput {
    source: URL!
    textPositionSelector: TextPositionSelectorInput
    textQuoteSelector: TextQuoteSelectorInput
}

"a part of a text; start and end are specified via character position; exact text included, prefix and suffix optional"
input TextPositionSelectorInput {
    start: Int!
    end: Int!
}

"a part of a text; exact text included, prefix and suffix optional"
input TextQuoteSelectorInput {
    exact: String!
    prefix: String
    suffix: String
}

"a part of an entity, selection is done using a choosable standard"
input TargetFragmentSelectorInput {
    source: URL!
    "the standard that is used to interpret the value"
    conformsTo: String!
    "a value using the specified standard"
    value: String!
}